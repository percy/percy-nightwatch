<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Canvas & Styles Test - Percy Nightwatch E2E</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-color: #667eea;
      --secondary-color: #764ba2;
      --accent-color: #ffd700;
      --text-color: #333;
      --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f5f7fa;
      color: var(--text-color);
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      background: var(--bg-gradient);
      color: white;
      padding: 40px;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 30px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
    }

    .section {
      background: white;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .section h2 {
      color: var(--primary-color);
      margin-bottom: 20px;
      font-size: 1.8rem;
      border-bottom: 3px solid var(--primary-color);
      padding-bottom: 10px;
    }

    .section p {
      line-height: 1.8;
      color: #555;
      margin-bottom: 15px;
    }

    .canvas-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .canvas-wrapper {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #e0e0e0;
    }

    .canvas-wrapper h3 {
      color: var(--secondary-color);
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .canvas-wrapper canvas {
      width: 100%;
      border-radius: 4px;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .info-badge {
      display: inline-block;
      background: var(--accent-color);
      color: var(--text-color);
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 0.9rem;
      font-weight: bold;
      margin: 5px;
    }

    .shadow-dom-demo {
      margin-top: 20px;
    }

    .code-block {
      background: #2d3748;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }

    .feature-list {
      list-style-position: inside;
      line-height: 2;
      color: #555;
    }

    .feature-list li {
      padding-left: 10px;
      border-left: 3px solid var(--primary-color);
      margin-bottom: 10px;
      padding-top: 5px;
      padding-bottom: 5px;
      background: #f8f9fa;
      border-radius: 4px;
    }

    .animated-box {
      width: 100%;
      height: 100px;
      background: var(--bg-gradient);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 1.3rem;
      font-weight: bold;
      animation: pulse 2s infinite;
      margin: 20px 0;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .css-custom-props-demo {
      background: var(--bg-gradient);
      padding: 20px;
      border-radius: 8px;
      color: white;
      text-align: center;
      margin: 15px 0;
    }

    /* Shadow DOM host styles */
    custom-card {
      display: block;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üé® Canvas & Styles Serialization Test</h1>
      <p>Testing canvas serialization and stylesheet error handling</p>
      <div style="margin-top: 15px;">
        <span class="info-badge">Canvas 2D</span>
        <span class="info-badge">WebGL</span>
        <span class="info-badge">Shadow DOM</span>
        <span class="info-badge">CSS Variables</span>
      </div>
    </header>

    <!-- Info Section -->
    <div class="section">
      <h2>üìã About This Test</h2>
      <p>
        This page tests the Percy Nightwatch SDK's ability to handle canvas serialization
        and stylesheet errors through the <code>ignoreCanvasSerializationErrors</code> and
        <code>ignoreStyleSheetSerializationErrors</code> options.
      </p>
      <h3 style="color: var(--primary-color); margin: 20px 0 10px 0;">Features Tested:</h3>
      <ul class="feature-list">
        <li><strong>Canvas 2D Context</strong> - Static and animated canvas rendering</li>
        <li><strong>WebGL Context</strong> - 3D graphics rendering with shaders</li>
        <li><strong>ignoreCanvasSerializationErrors</strong> - Graceful canvas error handling</li>
        <li><strong>ignoreStyleSheetSerializationErrors</strong> - Stylesheet CORS error handling</li>
        <li><strong>Shadow DOM</strong> - Web component style encapsulation</li>
        <li><strong>CSS Custom Properties</strong> - CSS variable serialization</li>
        <li><strong>Animations</strong> - CSS animations that should be captured</li>
      </ul>
    </div>

    <!-- Canvas 2D Section -->
    <div class="section">
      <h2>üñºÔ∏è Canvas 2D Context Tests</h2>
      <p>
        Testing 2D canvas context serialization with various drawing operations.
        Percy should capture the current canvas state.
      </p>

      <div class="canvas-grid">
        <div class="canvas-wrapper">
          <h3>Static Shapes</h3>
          <canvas id="canvas-2d-shapes" width="300" height="200"></canvas>
        </div>

        <div class="canvas-wrapper">
          <h3>Gradients & Text</h3>
          <canvas id="canvas-2d-gradients" width="300" height="200"></canvas>
        </div>

        <div class="canvas-wrapper">
          <h3>Complex Patterns</h3>
          <canvas id="canvas-2d-patterns" width="300" height="200"></canvas>
        </div>

        <div class="canvas-wrapper">
          <h3>Animated Canvas</h3>
          <canvas id="canvas-2d-animated" width="300" height="200"></canvas>
          <p style="font-size: 0.85rem; color: #777; margin-top: 10px;">
            This canvas has continuous animation that Percy should freeze
          </p>
        </div>
      </div>
    </div>

    <!-- WebGL Section -->
    <div class="section">
      <h2>üéÆ WebGL Context Tests</h2>
      <p>
        Testing WebGL context serialization. WebGL canvases may require special handling
        during serialization, which is where <code>ignoreCanvasSerializationErrors</code>
        becomes important.
      </p>

      <div class="canvas-grid">
        <div class="canvas-wrapper">
          <h3>WebGL Rotating Triangle</h3>
          <canvas id="canvas-webgl" width="300" height="300"></canvas>
          <p style="font-size: 0.85rem; color: #777; margin-top: 10px;">
            3D triangle rendered with WebGL shaders
          </p>
        </div>

        <div class="canvas-wrapper">
          <h3>WebGL with Textures</h3>
          <canvas id="canvas-webgl-texture" width="300" height="300"></canvas>
          <p style="font-size: 0.85rem; color: #777; margin-top: 10px;">
            Colored square demonstrating texture mapping
          </p>
        </div>
      </div>
    </div>

    <!-- CSS & Styles Section -->
    <div class="section">
      <h2>üé® CSS & Stylesheet Tests</h2>
      <p>
        Testing CSS custom properties (variables), animations, and potential stylesheet
        errors. Percy should handle CORS issues gracefully when
        <code>ignoreStyleSheetSerializationErrors</code> is enabled.
      </p>

      <div class="css-custom-props-demo">
        <h3 style="margin-bottom: 10px;">CSS Custom Properties Demo</h3>
        <p>Primary Color: <code>var(--primary-color)</code></p>
        <p>Secondary Color: <code>var(--secondary-color)</code></p>
        <p>Accent Color: <code>var(--accent-color)</code></p>
      </div>

      <div class="animated-box">
        Animated Element (CSS Pulse Animation)
      </div>

      <div class="code-block">
/* CSS Variables in Use */
:root {
  --primary-color: #667eea;
  --secondary-color: #764ba2;
  --accent-color: #ffd700;
}

/* Animation Definition */
@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}
      </div>
    </div>

    <!-- Shadow DOM Section -->
    <div class="section">
      <h2>üåì Shadow DOM Tests</h2>
      <p>
        Testing Shadow DOM serialization and style encapsulation. Shadow DOM creates
        isolated DOM trees with scoped styles.
      </p>

      <div class="shadow-dom-demo">
        <custom-card title="Shadow DOM Card 1" color="#667eea">
          This is content inside a shadow DOM web component with encapsulated styles.
        </custom-card>

        <custom-card title="Shadow DOM Card 2" color="#764ba2">
          Each component has its own isolated style tree that Percy needs to serialize correctly.
        </custom-card>

        <custom-card title="Shadow DOM Card 3" color="#f093fb">
          The SDK's <code>disableShadowDOM</code> option controls whether shadow roots are captured.
        </custom-card>
      </div>
    </div>

    <!-- Testing Instructions -->
    <div class="section">
      <h2>üß™ Testing Instructions</h2>
      <p><strong>To test canvas serialization errors:</strong></p>
      <ul class="feature-list">
        <li>Run without flags - default behavior</li>
        <li>Run with <code>ignoreCanvasSerializationErrors: false</code> - throw on canvas errors</li>
        <li>Run with <code>ignoreCanvasSerializationErrors: true</code> - suppress canvas errors</li>
      </ul>

      <p style="margin-top: 20px;"><strong>To test stylesheet serialization errors:</strong></p>
      <ul class="feature-list">
        <li>Run without flags - default behavior</li>
        <li>Run with <code>ignoreStyleSheetSerializationErrors: false</code> - throw on stylesheet errors</li>
        <li>Run with <code>ignoreStyleSheetSerializationErrors: true</code> - suppress stylesheet errors</li>
      </ul>

      <p style="margin-top: 20px;"><strong>Expected Percy Behavior:</strong></p>
      <ul class="feature-list">
        <li>All canvas content should be captured in the snapshot</li>
        <li>CSS variables and animations should be preserved</li>
        <li>Shadow DOM content should be included (unless disabled)</li>
        <li>Errors should be suppressed when ignore flags are enabled</li>
        <li>Visual rendering should match across test runs</li>
      </ul>
    </div>
  </div>

  <!-- Shadow DOM Custom Element Template -->
  <template id="custom-card-template">
    <style>
      :host {
        display: block;
      }
      .card {
        background: white;
        border: 3px solid var(--card-color, #667eea);
        border-radius: 12px;
        padding: 25px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .card-title {
        color: var(--card-color, #667eea);
        font-size: 1.5rem;
        margin-bottom: 15px;
        font-weight: bold;
      }
      .card-content {
        color: #555;
        line-height: 1.8;
      }
      .shadow-badge {
        display: inline-block;
        background: var(--card-color, #667eea);
        color: white;
        padding: 5px 12px;
        border-radius: 15px;
        font-size: 0.8rem;
        margin-top: 10px;
      }
    </style>
    <div class="card">
      <div class="card-title"></div>
      <div class="card-content">
        <slot></slot>
      </div>
      <div class="shadow-badge">Shadow DOM Component</div>
    </div>
  </template>

  <script>
    // Register custom element with Shadow DOM
    class CustomCard extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
      }

      connectedCallback() {
        const template = document.getElementById('custom-card-template');
        const content = template.content.cloneNode(true);

        const title = this.getAttribute('title') || 'Custom Card';
        const color = this.getAttribute('color') || '#667eea';

        content.querySelector('.card-title').textContent = title;
        content.querySelector('.card').style.setProperty('--card-color', color);

        this.shadowRoot.appendChild(content);
      }
    }
    customElements.define('custom-card', CustomCard);

    // Canvas 2D - Static Shapes
    const canvas2dShapes = document.getElementById('canvas-2d-shapes');
    const ctx2dShapes = canvas2dShapes.getContext('2d');

    // Draw rectangle
    ctx2dShapes.fillStyle = '#667eea';
    ctx2dShapes.fillRect(20, 20, 100, 80);

    // Draw circle
    ctx2dShapes.fillStyle = '#764ba2';
    ctx2dShapes.beginPath();
    ctx2dShapes.arc(200, 60, 40, 0, Math.PI * 2);
    ctx2dShapes.fill();

    // Draw triangle
    ctx2dShapes.fillStyle = '#ffd700';
    ctx2dShapes.beginPath();
    ctx2dShapes.moveTo(150, 120);
    ctx2dShapes.lineTo(200, 180);
    ctx2dShapes.lineTo(100, 180);
    ctx2dShapes.closePath();
    ctx2dShapes.fill();

    // Canvas 2D - Gradients & Text
    const canvas2dGradients = document.getElementById('canvas-2d-gradients');
    const ctx2dGrad = canvas2dGradients.getContext('2d');

    // Create gradient
    const gradient = ctx2dGrad.createLinearGradient(0, 0, 300, 200);
    gradient.addColorStop(0, '#667eea');
    gradient.addColorStop(1, '#764ba2');
    ctx2dGrad.fillStyle = gradient;
    ctx2dGrad.fillRect(0, 0, 300, 200);

    // Draw text
    ctx2dGrad.fillStyle = 'white';
    ctx2dGrad.font = 'bold 24px Arial';
    ctx2dGrad.textAlign = 'center';
    ctx2dGrad.fillText('Percy Test', 150, 100);
    ctx2dGrad.font = '16px Arial';
    ctx2dGrad.fillText('Canvas 2D', 150, 130);

    // Canvas 2D - Patterns
    const canvas2dPatterns = document.getElementById('canvas-2d-patterns');
    const ctx2dPatt = canvas2dPatterns.getContext('2d');

    // Create checkered pattern
    for (let i = 0; i < 10; i++) {
      for (let j = 0; j < 7; j++) {
        ctx2dPatt.fillStyle = (i + j) % 2 === 0 ? '#667eea' : '#764ba2';
        ctx2dPatt.fillRect(i * 30, j * 30, 30, 30);
      }
    }

    // Canvas 2D - Animated
    const canvas2dAnimated = document.getElementById('canvas-2d-animated');
    const ctx2dAnim = canvas2dAnimated.getContext('2d');
    let angle = 0;

    function animate() {
      ctx2dAnim.clearRect(0, 0, 300, 200);
      ctx2dAnim.save();
      ctx2dAnim.translate(150, 100);
      ctx2dAnim.rotate(angle);

      // Draw rotating square
      ctx2dAnim.fillStyle = '#667eea';
      ctx2dAnim.fillRect(-40, -40, 80, 80);

      // Draw rotating circle
      ctx2dAnim.fillStyle = '#ffd700';
      ctx2dAnim.beginPath();
      ctx2dAnim.arc(60, 0, 20, 0, Math.PI * 2);
      ctx2dAnim.fill();

      ctx2dAnim.restore();
      angle += 0.02;
      requestAnimationFrame(animate);
    }
    animate();

    // WebGL - Rotating Triangle
    const canvasWebGL = document.getElementById('canvas-webgl');
    const gl = canvasWebGL.getContext('webgl');

    if (gl) {
      // Vertex shader
      const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec4 aVertexColor;
        varying lowp vec4 vColor;
        void main() {
          gl_Position = aVertexPosition;
          vColor = aVertexColor;
        }
      `;

      // Fragment shader
      const fsSource = `
        varying lowp vec4 vColor;
        void main() {
          gl_FragColor = vColor;
        }
      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [
        0.0, 0.7,
        -0.7, -0.7,
        0.7, -0.7,
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      const colors = [
        1.0, 0.0, 0.0, 1.0,  // Red
        0.0, 1.0, 0.0, 1.0,  // Green
        0.0, 0.0, 1.0, 1.0,  // Blue
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

      gl.clearColor(0.9, 0.9, 0.95, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(shaderProgram);

      const positionLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(positionLocation);

      const colorLocation = gl.getAttribLocation(shaderProgram, 'aVertexColor');
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(colorLocation);

      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    // WebGL - Textured Square
    const canvasWebGLTexture = document.getElementById('canvas-webgl-texture');
    const gl2 = canvasWebGLTexture.getContext('webgl');

    if (gl2) {
      gl2.clearColor(0.2, 0.2, 0.3, 1.0);
      gl2.clear(gl2.COLOR_BUFFER_BIT);

      // Simple colored square
      const vsSource2 = `
        attribute vec4 aVertexPosition;
        void main() {
          gl_Position = aVertexPosition;
        }
      `;

      const fsSource2 = `
        void main() {
          gl_FragColor = vec4(0.4, 0.5, 0.9, 1.0);
        }
      `;

      const vertexShader2 = createShader(gl2, gl2.VERTEX_SHADER, vsSource2);
      const fragmentShader2 = createShader(gl2, gl2.FRAGMENT_SHADER, fsSource2);

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }

      const program2 = gl2.createProgram();
      gl2.attachShader(program2, vertexShader2);
      gl2.attachShader(program2, fragmentShader2);
      gl2.linkProgram(program2);

      const buffer2 = gl2.createBuffer();
      gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2);
      const positions2 = [
        -0.6, 0.6,
        0.6, 0.6,
        -0.6, -0.6,
        0.6, -0.6,
      ];
      gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(positions2), gl2.STATIC_DRAW);

      gl2.useProgram(program2);
      const posLoc2 = gl2.getAttribLocation(program2, 'aVertexPosition');
      gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer2);
      gl2.vertexAttribPointer(posLoc2, 2, gl2.FLOAT, false, 0, 0);
      gl2.enableVertexAttribArray(posLoc2);

      gl2.drawArrays(gl2.TRIANGLE_STRIP, 0, 4);
    }
  </script>
</body>
</html>
